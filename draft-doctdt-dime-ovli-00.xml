<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'> 
<!ENTITY RFC2234 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2234.xml'>     
<!ENTITY RFC3588 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml'>     
<!ENTITY RFC4005 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4005.xml'> 
<!ENTITY RFC4072 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml'> 
<!ENTITY RFC3748 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml'> 
<!ENTITY RFC4282 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml'> 
<!ENTITY RFC4284 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4284.xml'> 
<!ENTITY RFC4283 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4283.xml'> 
<!ENTITY RFC2486 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2486.xml'> 
<!ENTITY RFC2865 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml'> 
<!ENTITY RFC5113 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5113.xml'> 
<!ENTITY RFC1034 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'> 
<!ENTITY RFC1035 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml'> 
<!ENTITY RFC3490 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml'> 
<!ENTITY RFC6408 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6408.xml'> 
<!ENTITY RFC6733 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6733.xml'> 
<!ENTITY RFC5226 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'> 


<!ENTITY I-D.mcmurry-dime-overload-reqs PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dime-overload-reqs-10'> 
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?><?rfc subcompact="yes" ?>
<rfc ipr="trust200902"

    category="std"
     docName="draft-docdt-dime-ovli-00.txt">
  <front>
    <title abbrev="Dimeter Overload Indication">Dimeter Overload Indication</title>

    <author role="editor" initials="J" surname="Korhonen" fullname="Jouni Korhonen">
      <organization>Renesas Mobile</organization>
         <address>
                <postal>
                    <street>Porkkalankatu 24</street>
                    <city>Helsinki</city>
                    <code>FIN-00180</code>
                    <country>Finland</country>
                </postal>
                <email>jouni.nospam@gmail.com</email>
            </address>
    </author>


    <date year="2013"/>
    <area>Operations and Management</area>
    <workgroup>Diameter Maintenance and Extensions (DIME)</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Diameter</keyword>
    <keyword>Overload</keyword>
<abstract>
 <t>This specification documents a Diameter Overload Control Indication and
  the dissemination of the overload indication information.
      </t>
    </abstract>

  <note title="Requirements">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref
   target="RFC2119">RFC 2119</xref>.
   </t>
  </note>
 </front>
 
<middle>

<section title="Introduction" anchor="intro">
 <t>...
 </t>
 <t>We also need to describe carefully what is in the scope of this
  document and what is left for the future documents. Maybe this
  deserves a new subsection?
 </t>
</section>

<section title="Terminology and Abbreviations" anchor="abbrev">
 <t>...
 </t>
</section>


<section title="Solution Overview">
 <section title="Architectural Assumptions">
  <t>Describe here on what basis the solution is intended to work. This lists 
  things like piggybacking, end-to-end semantics, role of Diameter agents, etc.
  </t>
  
  <section title="Application Classification">
      <t>
        The following is a classification of Diameter applications and requests.  This discussion is meant to                document factors that play into decisions made by the Diameter identity responsible for handling overload            reports.
      </t>

<t>
Section 8.1 of RFC6733 defines two state machines that imply two types of applications, session-less and session-based.  The primary differentiator between these types of applications is the lifetime of Session-IDs.  
</t>
<t>
For session-based applications, the session-id is used to tie multiple requests into a single session.  
</t>
<t>
In session-less applications, the lifetime of the session-id is a single Diameter transaction.
</t>
<t>
The 3GPP-defined S6a application is an example of a session-less application.  The following, copied from section 7.1.4 of 29.272, explicitly states that sessions are implicitly terminated and that the server does not maintain session state:
</t>

<list>
<t>
"Between the MME and the HSS and between the SGSN and the HSS and between the MME and the EIR, Diameter sessions shall be implicitly terminated. An implicitly terminated session is one for which the server does not maintain state information. The client shall not send any re-authorization or session termination requests to the server.
</t>
<t>
The Diameter base protocol includes the Auth-Session-State AVP as the mechanism for the implementation of implicitly terminated sessions.
</t>
<t>
The client (server) shall include in its requests (responses) the Auth-Session-State AVP set to the value NO_STATE_MAINTAINED (1), as described in IETF RFC 3588 [4]. As a consequence, the server shall not maintain any state information about this session and the client shall not send any session termination request. Neither the Authorization-Lifetime AVP nor the Session-Timeout AVP shall be present in requests or responses."
</t>
</list>
<t>
For the purposes of this discussion, session-less applications are further divided into two types of applications:
</t>

<list style=’symbols’>
<t>
- Stateless applications - Requests within a stateless application have no relationship to each other.  The 3GPP defined S13 application is an example of a stateless application.
</t>
<t>
- Pseudo-session applications - While this class of application does not use the Diameter Session-ID AVP to correlate requests, there is an implied ordering of transactions defined by the application.  The 3GPP defined Cx application is an example of a pseudo-session application.
</t>
</list>

<t>
The accounting application defined in RFC6733 and the Credit-Control application defined in RFC4006 are examples of Diameter session-based applications.
</t>
<t>
The handling of overload reports must take the type of application into consideration, as discussed in section xxxxx.
</t>

  </section>
  
  <section title="Application Type Overload Implications">

<t>
This section discusses considerations for mitigating overload reported by a Diameter entity.  This discussion focuses on the type of application.  Section xxxx discussion considerations for handling various request types when the target server is known to be in an overloaded state.  Section xxxx discusses considerations for handling overload conditions based on the network deployment scenario.
</t>
<t>
These discussions assume that the strategy for mitigating the reported overload is to reduce the overall workload on the overloaded entity.  The concept of applying overload treatment to requests targeted for an overloaded Diameter entity is inherent to this discussion.  The overload treatment is not specified here but could include routing the request to another Diameter entity known to be able to handle the request.  Overload treatment could also include rejecting the request.  For a Diameter agent, rejecting a request will generally mean rejecting could be generating an appropriate Diameter error response   For a Diameter client, rejecting the request could mean giving an indication to the entity requesting the Diameter service that the network is busy and to try again later.
</t>
<t>
Stateless applications - By definition there is no relationship between individual requests in a stateless application.  As a result, when a request is sent or relayed to an overloaded Diameter entity -- either a Diameter Server or a Diameter Agent -- the sending/relaying entity can choose to apply overload treatment to any request targeted for the overloaded entity.
</t>
<t>
Pseudo stateful applications – Pseudo stateful applications are also stateless applications in that there is no session Diameter state maintained between transactions.  There is, however, an implied ordering of requests.  As a result, decisions about which transactions to reject as a result of an overloaded entity could/should take the command-code of the request into consideration.  This generally means that transactions later in the sequence of transactions should be given more favorable treatment than messages earlier in the sequence.   This is because more work has already been done by the Diameter network for those transactions that occur later in the sequence.  Rejecting them could result in increasing the load on the network as the transactions earlier in the sequence might also need to be repeated.
</t>
<t>
Stateful applications – Overload handling for stateful applications must take into consideration the work associated with setting up an maintaining a session.  As such, the entity handling overload of a Diameter entity for a stateful application might tend to reject new session requests before rejecting intra-session requests.  In addition, session ending requests might be given a lower priority of being rejected as rejecting session ending requests could result in session status being out of sync between the Diameter clients and servers.
</t>
      
      
  </section>
  <section title="Request Transaction Classification">
<t>
Independent Request - An independent request is not a part of a Diameter session and, as such, the lifetime of the session-id is constrained to an individual transaction.  
</t>
<t>
Session-Initiating Request - A session-initiating request is the initial message that establishes a Diameter session.  The ACR message defined in RFC 6733 is an example of a session-initiating request.
</t>
<t>
Correlated Session-Initiating Request - There are cases, most notably in the 3GPP PCC architecture, where multiple Diameter sessions are correlated and must be handled by the same Diameter server.  This is a special case of a Session-Initiating Request.  Gx CCR-I requests and Rx AAR messages are examples of correlated session-initiating requests.
</t>
<t>
Intra-Session Request - An intra session request is a request that uses a session-id for an already established request.  An intra session request generally needs to be delivered to the server that handled the session creating request for the session.  The STR message defined in RFC 6733 is an example of an intra-session requests.  CCR-U and CCR-T requests defined in RFC4006 are further examples of intra-session requests.
</t>
<t>
Pseudo-Session Requests - Pseudo session requests are independent requests and, as such, the request transactions are not tied together using the Diameter session-id.  There exist Diameter applications that define an expected ordering of transactions.  This sequencing of independent transactions results in a pseudo session.  The AIR, MAR and SAR requests in the 3GPP defined Cx application are examples of pseudo-session requests.
</t>
      
  </section>
  
  <section title="Request Type Overload Implications">
      
<t>
Independent requests - Independent requests can be given equal treatment when making throttling decisions.
</t>
<t>
Session-creating requests – Session-creating requests represent more work than independent or intra-session requests.   As such, throttling decisions might favor intra-session requests over session-creating requests.  Individual session-creating requests can be given equal treatment when making throttling decisions.
</t>
<t>
Correlated session-creating requests – Requests that result in a new binding, where the binding is used for routing of subsequent session-creating requests, represent more work than all other requests.  As such, these requests might be throttled more frequently than other request types.
</t>
<t>
Pseudo-session requests – Throttling decisions for pseudo-session requests can take where individual requests fit into the overall sequence of requests within the pseudo session.  Requests that are earlier in the sequence might be throttled more aggressively than requests that occur later in the sequence.
</t>
<t>
Intra-session requests – There are two classes of intra-sessions requests.  The first is a request that ends a session.  The second is a request that is used to convey session related state between the Diameter client and server.  Session ending request should be throttled less aggressively in order to keep session state consistent between the client and server.  The default handling of other intra-session requests might be to treat them equally when making throttling decisions.   There might also be application level considerations whether some request types are favored over others.
</t>
      
  </section>
  
  <section title="Diameter Deployment Scenarios">
      
<t>
This section discusses various Diameter network deployment scenarios and the implications of those deployment models on handling of overload reports.
</t>
<t>
The scenarios vary based on the following:
</t>

<list style=’symbols”>
<t>
The presence or absence of Diameter agents
</t>
<t>
Which Diameter entities support the DOC extension
</t>
<t>
The amount of the network topology understood by Diameter clients
</t>
<t>
The complexity of the Diameter server deployment for a Diameter application
</t>
<t>
Number of Diameter applications supported by Diameter clients and Diameter servers
</t>
</list>

<t>
Without consideration for which elements support the DOC extension, the following is a representative list of deployment scenarios:
</t>
<list style=’symbols’>
<t>
Client <-> Server
</t>
<t>
Client <-> Multiple equivalent servers
</t>
<t>
Client <-> Agent <-> Multiple equivalent servers
</t>
<t>
Client <-> Agent [ <-> Agent ] <-> Partitioned server
</t>
<t>
Client <-> Edge Agent [ <-> Edge Agent] <-> { Multiple Equivalent Servers | Partitioned Servers }
</t>
<t>
Client <-> Session Correlating Agent <-> Multiple Equivalent Servers
</t>
</list>

<t>
The following is a list of representative deployment scenarios:
</t>

<list style=symbols>
<t>
Direct connection between a DOC client and a DOC server
</t>
<t>
DOC client <-> non-DOC agent <-> DOC server
</t>
<t>
DOC client <-> DOC agent <-> DOC server
</t>
<t>
Non-DOC client <-> DOC agent <-> DOC server
</t>
<t>
Non-DOC client <-> DOC agent <-> Mix of DOC and non-DOC servers
</t>
<t>
DOC client <-> agent <-> Partitioned/Segmented DOC server
</t>
<t>
DOC client <-> agent <-> agent <-> Partitioned/Segmented DOC server
</t>
<t>
DOC client <-> edge agent <-> edge agent <-> DOC server
</t>
      
  </section>

  <section title="Diameter Agent Behaviour">
   <t>In the context of the Diameter Overload Indication dissemination and reacting to
    the overload information, the functional behaviour of the Diameter agnets in front
    of servers, especially concerning Diameter proxies, has to be common. This is
    topical since intelligent Diameter agents may actively participate to the
    overload condition handling (such as do intelligent next hop selection based on
    the overload conditions or aggregate overload information to be disseminated).
    Further, Diameter agents
    may also have other deployment related tasks that are not defined in the Diameter
    base protocol <xref target="RFC6733"/>. These include, among others, topology hiding
    and acting as a server representative for a cluster of real Diameter servers for the
    Diameter client. To be efficient, such network topologies imply that the Diameter
    agents in front of servers remain in the Diameter signaling path for all the messages
    related to the same session/user.
   </t>
   <t>Since the solution defined in this specification MUST NOT break the Diameter
    base protocol assumptions at any time, great care has to be taken not to assume
    functionality from the Diameter agents that would, at the base protocol level and
    between two Diameter end nodes break or assume functionality beyond the
    Diameter base protocol. Effectively this means the following from a Diameter agent:
   </t>
   <t>
    <list style="symbols">
    <t>A Diameter agent that impersonates itself as the "end node", i.e. the server to a
     Diameter client MUST NOT leak any Diameter base protocol level information of the
     Diameter nodes behind it. From the Diameter client point of view the final
     destination to its requests and the original source for the answers MUST be the
     Diameter agent. Effectively this requirement means the Diameter agent acts as a
     back-to-back-agent. How the Diameter agent in this case appears to the Diameter
     nodes it is representing (i.e. the real Diameter servers), is an implementation and
     a deployment specific within the realm the Diameter agent is deployed.
    <vspace blankLines="1"/></t>
    
    <t>This requirement also implies that if the Diameter agent is not
     able to impersonate the servers behind it, the Diameter dialogue is always
     established between clients and servers and any overload information received
     by a client would be from a given server identified by the Origin-Host identity.
    </t>
    </list>
   </t>
    
   
  </section>

  <section title="Simplified Example Architecture">
   <t>**Early Draft!**
   </t>

<figure title="Simplified architecture choices for overload indication delivery">
 <artwork><![CDATA[
 Realm X                                  Other Realms
<--------------------------------------> <---------------------->

+--^-----+                 : (optional) :
|Diameter|                 :            :
|Server A|--+     .--.     : +---^----+ :     .--.     
+--------+  |   _(    `.   : |Diameter| :   _(    `.   +---^----+
            +--(        )--:-|  Agent |-:--(        )--|Diameter|
+--------+  | ( `  .  )  ) : +-----^--+ : ( `  .  )  ) | Client |
|Diameter|--+  `--(___.-'  :            :  `--(___.-'  +-----^--+
|Server B|                 :            :
+---^----+                 :            :
            Overload Indication A    Overload Indication A'
       1)  <----------------------> <---------------------->
           standard base protocol   standard base protocol

            End-to-end Overload Indication
       2)  <----------------------------------------------->
                       standard base protocol


]]></artwork></figure>
  </section>


 </section>

 <section title="Clarifications to Diameter Base Protocol">
  <t>Describe here, assuming there is a need, what parts of the
   existing Diameter Base Protocol <xref target="RFC6733"/> needs
   clarification in the even of the overload condition.
  </t>
 </section>

 <section title="Dissemination of the Overload Indication" anchor="piggy">
  <t>Explain, e.g. the piggybacking of Overload Indication AVPs in this
   section. Explain how possible feature negotiation is done?
  </t>
  
  <section title="Negotiation and Versioning">
  </section>

  <section title="Transmission of the Attribute Value Pairs">
  </section>
  
 </section>

 <section title="Overload Condition Indication">
  <t>Describe here what the overload condition indication is about.
  </t>
 </section>

 
</section>

<section title="Attribute Value Pairs" anchor="avps">
 <t>This section describes the encoding and semantics of
  Overload Indication Attribute Value Pairs (AVPs).
 </t>
 <section title="xyz AVP" anchor="xyz">
  <t>...
  </t>
 </section>

 <section title="abc AVP" anchor="abc">
  <t>...
  </t>
 </section>

 <section title="Attribute Value Pair flag rules">
  <figure><artwork><![CDATA[
                                                    +---------+
                                                    |AVP flag |
                                                    |rules    |
                                                    +----+----+
                  AVP   Section                     |    |MUST|
 Attribute Name   Code  Defined  Value Type         |MUST| NOT|
+---------------------------------------------------+----+----+
|abc              TBD3  x.x      Grouped            |    | V  |
+---------------------------------------------------+----+----+
|xyz              TBD4  x.x      Unsigned32         |    | V  |
+---------------------------------------------------+----+----+
]]></artwork></figure>
 </section>
</section>


<section title="Transport Considerations" anchor="transport">
 <t>If anything needs to be said beyond what has been defined
  in <xref target="piggy"/>. One candidate is, e.g. the use of
  SCTP Payload Protocol Identifier (PPID). Also one might spend
  some more time discussion the implications of agents between the
  "client" and the "server".
 </t>
</section>


<section title="IANA Considerations">
 <section title="AVP codes">
  <t>New AVPs defined by this specification are listed in <xref target="avps"/>.
   All AVP codes allocated from the  'Authentication,  Authorization, and
   Accounting (AAA) Parameters' AVP Codes registry.
  </t>
 </section>
 <section title="Result-Code values">
  <t>This specification adds...:
  </t>
  <figure><artwork><![CDATA[
AVP Values | Attribute Name                | Reference
-----------+-------------------------------+----------
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
]]></artwork></figure>
 </section>
 <section title="New registries">
 <t>XYZ new registries are needed under the 'Authentication,  Authorization, 
 and Accounting (AAA) Parameters' registry:
 </t>
 <t><list style="symbols">
  <t>aaa.</t>
  <t>bbb.</t>
  <t>ccc.</t>
 </list>
 </t>
 </section>
</section>

<section title="Security Considerations">
 <t>No end to end security. We need to live with that.
 </t>
</section>

<section title="Design Team Members">
 <t>This document is a product of the following Diameter Overload Control Design Team
  members:
 </t>
 <t><list style="symbols">
  <t>Ben Campbell</t>
  <t>Eric McMurry</t>
  <t>Hannes Tschofenig</t>
  <t>Jean-Jacques Trottin</t>
  <t>Jouni Korhonen</t>
  <t>Lionel Morand</t>
  <t>Maria Cruz Bartolome</t>
  <t>Martin Dolly</t>
  <t>Nirav Salot</t>
  <t>Steve Donovan</t>
  <t>Susan Shishufeng</t>
 </list>
 </t>
</section>


<section title="Acknowledgements">
 <t>...
 </t>
</section>


</middle>

    <!-- ====================================================================== -->

<back>
 <references title="Normative References">
  &RFC2119;
  &RFC6733;
  &RFC5226;
 </references>

 <references title="Informative References">
  &I-D.mcmurry-dime-overload-reqs;
 </references>

    <!-- ====================================================================== -->

 <section title="Examples">
  <section title="3GPP S6a interface overload indication">
   <t>Would cover S6a MME-HSS communication with several topology
    choices (such as with or without DRA, and with "generic" agents).
   </t>
  </section>

  <section title="3GPP PCC interfaces overload indication">
   <t>Would cover Gx/Rx and maybe S9.. 
   </t>
  </section>
 </section>



</back>
</rfc>
