<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'> 
<!ENTITY RFC2234 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2234.xml'>     
<!ENTITY RFC3588 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml'>     
<!ENTITY RFC4005 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4005.xml'> 
<!ENTITY RFC4072 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml'> 
<!ENTITY RFC3748 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml'> 
<!ENTITY RFC4282 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml'> 
<!ENTITY RFC4284 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4284.xml'> 
<!ENTITY RFC4283 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4283.xml'> 
<!ENTITY RFC2486 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2486.xml'> 
<!ENTITY RFC2865 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml'> 
<!ENTITY RFC5113 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5113.xml'> 
<!ENTITY RFC1034 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'> 
<!ENTITY RFC1035 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml'> 
<!ENTITY RFC3490 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml'> 
<!ENTITY RFC6408 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6408.xml'> 
<!ENTITY RFC6733 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6733.xml'> 
<!ENTITY RFC5226 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'> 
<!ENTITY RFC4006 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4006.xml'>


<!ENTITY I-D.ietf-dime-overload-reqs PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dime-overload-reqs-13.xml'> 
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?><?rfc subcompact="no" ?>
<rfc ipr="trust200902"

    category="std"
     docName="draft-docdt-dime-ovli-00.txt">
  <front>
    <title abbrev="Dimeter Overload Indication">Dimeter Overload Indication</title>

    <author role="editor" initials="J" surname="Korhonen" fullname="Jouni Korhonen">
      <organization>Broadcom</organization>
         <address>
                <postal>
                    <street>Porkkalankatu 24</street>
                    <city>Helsinki</city>
                    <code>FIN-00180</code>
                    <country>Finland</country>
                </postal>
                <email>jouni.nospam@gmail.com</email>
            </address>
    </author>

    <author initials="S" surname="Donovan" fullname="Steve Donovan">
      <organization>Oracle</organization>
         <address>
                <postal>
                    <street>17210 Campbell Road</street>
                    <city>Dallas</city>
                    <region>Texas</region>
                    <code>75254</code>
                    <country>United States</country>
                </postal>
                <email>srdonovan@usdonovans.com</email>
            </address>
    </author>

    <date year="2013"/>
    <area>Operations and Management</area>
    <workgroup>Diameter Maintenance and Extensions (DIME)</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Diameter</keyword>
    <keyword>Overload</keyword>
<abstract>
 <t>This specification documents a Diameter Overload Control base solution and
  the dissemination of the overload report information.
      </t>
    </abstract>

  <note title="Requirements">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref
   target="RFC2119">RFC 2119</xref>.
   </t>
  </note>
 </front>
 
<middle>

<section title="Introduction" anchor="intro">
 <t>This specification defines a base solution for the Diameter Overload
  Control. The requirements for the solution are described and discussed
  in the corresponsing design requirements document <xref
  target="I-D.ietf-dime-overload-reqs"/>. Note that the overload
  control solution  defined in this specification does not address all
  the requirements listed in <xref target="I-D.ietf-dime-overload-reqs"/>.
  A number of overload control related features are left for the
  future specifications. See <xref target="ffs"/> for more detailed
  discussion on those.
 </t>
</section>

<section title="Terminology and Abbreviations" anchor="abbrev">

 <t><list style="hanging">
 <t hangText="Server Farm"><vspace blankLines="1"/>
 A set of Diameter servers that can handle any request for a given Diameter applications.  While these servers support the same set of applications, they do not necessarily all have the same capacity.  An individual server farm might also support a subset of the users for a Diameter Realm. </t>
 
 <t hangText="Server Front End"><vspace blankLines="1"/>
 A Server Front End (SFE) is a role that can be performed by a Diameter agent -- either a relay or a proxy -- that sits between Diameter clients and a Server Farm. An SFE can perform various functions for the server farm it sits in front of.  This includes some or all of the following functions:
 <list style="symbols">
     <t>Diameter Routing</t>
     <t>Diameter layer load balancing</t>
     <t>Load Management</t>
     <t>Overload Management</t>
     <t>Topology Hiding</t>
     <t>Server Farm Identity Management</t>
 </list>
 </t>

 <t hangText="Diameter Routing"><vspace blankLines="1"/>
  Routing of Diameter messages addressed to either a Diameter Realm or a
  specific Diameter-Host.  This function is defined in <xref target="RFC6733"/>.
  Application level routing specifications that expand on <xref target="RFC6733"/>
  also exis.</t>
 
 <t hangText="Diameter-layer Load Balancing"><vspace blankLines="1"/>
  Diameter layer load balancing allows Diameter requests to be distributed across
  the set of servers. Definition of this function is outside the scope of this
  document. </t>
 
 <t hangText="Load Management"><vspace blankLines="1"/>
  This functionality ensures that the consolidated load state for the
  server farm is collected, and processed. The exact algorithm for computing
  the load at the SFE is implementation specific but enough semantic of the
  conveyed load information needs to be specified so that deterministic
  behavior can be ensured. </t>
 
 <t hangText="Overload Management"><vspace blankLines="1"/>
  The SFE is the entity that understands the consolidated overload state
  for the server farm.  Just as it is outside the scope of this document
  to specify how a Diameter server calculates its overload state, it is
  also outside the scope of this document to specify how an SFE calculates
  the overload state for the set of servers.  This document describes how
  the SFE communicates Overload information to Diameter Clients. </t>

 <t hangText="Topology Hiding"><vspace blankLines="1"/>
  Topology Hiding is loosely defined as ensuring that no Diameter topology
  information about the server farm can be discovered from Diameter messages
  sent outside a predefined boundary (typically administrative domain).  This
  includes obfuscating identifiers and address information of Diameter entities
  in the server farm.  It can also include hiding the number of various Diameter
  entities in the server farm.  Identifying information can occur in many
  Diameter AVPs, including Origin-Host, Destination-Host, Route-Record,
  Proxy-Info, Session-ID and other AVPs.
 </t>
 
 <t hangText="Server Farm Identity Management"><vspace blankLines="1"/>
  Server Farm Identity Management (SFIM) is a mechanism that can be used by
  the SFE to present a single Diameter identity that can be used by clients
  to send Diameter requests to the server farm.  This requires that the SFE
  modifies Origin-Host information in answers coming from servers in the
  server farm. An agent that performs SFIM appears as a server from the
  client's perspective. </t>
</list>
</t>
</section>


<section title="Solution Overview">
 <section title="Architectural Assumptions">
  <t>Describe here on what basis the solution is intended to work. This lists 
  things like piggybacking, end-to-end semantics, role of Diameter agents, etc.
  </t>
  
  <section title="Application Classification">
   <t>The following is a classification of Diameter applications and requests. 
    This discussion is meant to document factors that play into decisions made
    by the Diameter identity responsible for handling overload reports.
   </t>

   <t>Section 8.1 of <xref target="RFC6733"/> defines two state machines that imply two
    types of applications, session-less and session-based.  The primary differentiator
	between these types of applications is the lifetime of Session-IDs.  
   </t>

   <t>For session-based applications, the session-id is used to tie multiple requests into
    a single session.  
   </t>

   <t>In session-less applications, the lifetime of the session-id is a single Diameter
    transaction.
   </t>

   <t>The 3GPP-defined S6a application is an example of a session-less application.
    The following, copied from section 7.1.4 of 29.272, explicitly states that
    sessions are implicitly terminated and that the server does not maintain session state:
   </t>

   <t><list>
    <t>"Between the MME and the HSS and between the SGSN and the HSS and between the MME
     and the EIR, Diameter sessions shall be implicitly terminated. An implicitly
     terminated session is one for which the server does not maintain state information.
     The client shall not send any re-authorization or session termination requests to
     the server.
    </t>
    <t>The Diameter base protocol includes the Auth-Session-State AVP as the mechanism for
     the implementation of implicitly terminated sessions.
    </t>
    <t>The client (server) shall include in its requests (responses) the Auth-Session-State
     AVP set to the value NO_STATE_MAINTAINED (1), as described in <xref target="RFC6733"/>.
     As a consequence, the server shall not maintain any state information about this
     session and the client shall not send any session termination request. Neither the
     Authorization-Lifetime AVP nor the Session-Timeout AVP shall be present in requests
     or responses."
    </t>
   </list>
   </t>

   <t>For the purposes of this discussion, session-less applications are further divided
    into two types of applications:
   </t>

   <t><list style="hanging">
    <t hangText="Stateless applications"> Requests within a stateless application have no
     relationship to each other.  The 3GPP defined S13 application is an example
     of a stateless application.
    </t>
    <t hangText="Pseudo-session applications"> While this class of application does not use the
     Diameter Session-ID AVP to correlate requests, there is an implied ordering of
     transactions defined by the application.  The 3GPP defined Cx application is an
     example of a pseudo-session application.
    </t>
   </list>
   </t>

   <t>The accounting application defined in <xref target="RFC6733"/> and the
    Credit-Control application defined in <xref target="RFC4006"/> are examples
	of Diameter session-based applications.
   </t>
   <t>The handling of overload reports must take the type of application into
    consideration, as discussed in section xxxxx.
   </t>
  </section>
  
  <section title="Application Type Overload Implications">

  <t>This section discusses considerations for mitigating overload reported by a Diameter
   entity.  This discussion focuses on the type of application.  Section xxxx discussion
   considerations for handling various request types when the target server is known to
   be in an overloaded state.  Section xxxx discusses considerations for handling
   overload conditions based on the network deployment scenario.
  </t>
  <t>These discussions assume that the strategy for mitigating the reported overload is
   to reduce the overall workload on the overloaded entity.  The concept of applying
   overload treatment to requests targeted for an overloaded Diameter entity is inherent
   to this discussion.  The overload treatment is not specified here but could include
   routing the request to another Diameter entity known to be able to handle the request.
   Overload treatment could also include rejecting the request.  For a Diameter agent,
   rejecting a request will generally mean rejecting could be generating an appropriate
   Diameter error response   For a Diameter client, rejecting the request could mean
   giving an indication to the entity requesting the Diameter service that the network
   is busy and to try again later.
  </t>
  <t><list style="hanging">
   <t hangText="Stateless applications"> By definition there is no relationship between individual
   requests in a stateless application.  As a result, when a request is sent or relayed
   to an overloaded Diameter entity - either a Diameter Server or a Diameter Agent
   - the sending/relaying entity can choose to apply overload treatment to any request
   targeted for the overloaded entity.
  </t>
  <t hangText="Pseudo stateful applications"> Pseudo stateful applications are also stateless
   applications in that there is no session Diameter state maintained between
   transactions.  There is, however, an implied ordering of requests.  As a result,
   decisions about which transactions to reject as a result of an overloaded entity
   could/should take the command-code of the request into consideration.  This generally
   means that transactions later in the sequence of transactions should be given more
   favorable treatment than messages earlier in the sequence.   This is because more
   work has already been done by the Diameter network for those transactions that
   occur later in the sequence.  Rejecting them could result in increasing the load
   on the network as the transactions earlier in the sequence might also need to be
   repeated.
  </t>
  <t hangText="Stateful applications"> Overload handling for stateful applications must take into
   consideration the work associated with setting up an maintaining a session.  As such,
   the entity handling overload of a Diameter entity for a stateful application might
   tend to reject new session requests before rejecting intra-session requests.  In
   addition, session ending requests might be given a lower priority of being rejected
   as rejecting session ending requests could result in session status being out of
   sync between the Diameter clients and servers.
  </t></list>
  </t>
  </section>
  <section title="Request Transaction Classification">
   <t><list style="hanging">
   <t hangText="Independent Request">An independent request is not a part of a Diameter session and,
    as such, the lifetime of the session-id is constrained to an individual transaction.  
   </t>
   <t hangText="Session-Initiating Request"> A session-initiating request is the initial message
    that establishes a Diameter session.  The ACR message defined in
    <xref target="RFC6733"/> is an example of a session-initiating request.
   </t>
   <t hangText="Correlated Session-Initiating Request"> There are cases, most notably in the 3GPP
    PCC architecture, where multiple Diameter sessions are correlated and must be handled
    by the same Diameter server.  This is a special case of a Session-Initiating Request.
    Gx CCR-I requests and Rx AAR messages are examples of correlated session-initiating
    requests.
   </t>
   <t hangText="Intra-Session Request"> An intra session request is a request that uses a
    session-id for an already established request.  An intra session request generally
    needs to be delivered to the server that handled the session creating request for
    the session.  The STR message defined in RFC 6733 is an example of an intra-session
    requests.  CCR-U and CCR-T requests defined in RFC4006 are further examples of
    intra-session requests.
   </t>
   <t hangText="Pseudo-Session Requests"> Pseudo session requests are independent requests and,
    as such, the request transactions are not tied together using the Diameter
    session-id.  There exist Diameter applications that define an expected ordering
    of transactions.  This sequencing of independent transactions results in a pseudo
    session.  The AIR, MAR and SAR requests in the 3GPP defined Cx application are
    examples of pseudo-session requests.
   </t>   
   </list>
   </t>
  </section>
  
  <section title="Request Type Overload Implications">
   <t>Independent requests - Independent requests can be given equal treatment when
    making throttling decisions.
   </t>
   <t>Session-creating requests – Session-creating requests represent more work than
    independent or intra-session requests.   As such, throttling decisions might
    favor intra-session requests over session-creating requests.  Individual
    session-creating requests can be given equal treatment when making throttling
    decisions.
   </t>
   <t>Correlated session-creating requests – Requests that result in a new binding,
    where the binding is used for routing of subsequent session-creating requests,
    represent more work than all other requests.  As such, these requests might be
    throttled more frequently than other request types.
   </t>
   <t>Pseudo-session requests – Throttling decisions for pseudo-session requests can
    take where individual requests fit into the overall sequence of requests within
    the pseudo session.  Requests that are earlier in the sequence might be throttled
    more aggressively than requests that occur later in the sequence.
   </t>
   <t>Intra-session requests – There are two classes of intra-sessions requests.
    The first is a request that ends a session.  The second is a request that is
    used to convey session related state between the Diameter client and server. 
    Session ending request should be throttled less aggressively in order to keep
    session state consistent between the client and server.  The default handling
    of other intra-session requests might be to treat them equally when making
    throttling decisions.   There might also be application level considerations
    whether some request types are favored over others.
   </t>   
  </section>
  
  <section title="Diameter Deployment Scenarios">
   <t>This section discusses various Diameter network deployment scenarios and the
    implications of those deployment models on handling of overload reports.
   </t>
   <t>The scenarios vary based on the following:
   </t>

   <t><list style="symbols">
    <t>The presence or absence of Diameter agents</t>
    <t>Which Diameter entities support the DOC extension</t>
    <t>The amount of the network topology understood by Diameter clients</t>
    <t>The complexity of the Diameter server deployment for a Diameter application</t>
    <t>Number of Diameter applications supported by Diameter clients and Diameter
     servers</t>
   </list>
   </t>

   <t>Without consideration for which elements support the DOC extension, the following
    is a representative list of deployment scenarios:
   </t>

  <t><list style="symbols">
   <t>Client --- Server</t>
   <t>Client --- Multiple equivalent servers</t>
   <t>Client --- Agent --- Multiple equivalent servers</t>
   <t>Client --- Agent [ --- Agent ] --- Partitioned server</t>
   <t>Client --- Edge Agent [ --- Edge Agent] ---
    { Multiple Equivalent Servers | Partitioned Servers }</t>
   <t>Client --- Session Correlating Agent --- Multiple Equivalent Servers</t>
  </list>
  </t>

  <t>The following is a list of representative deployment scenarios:
  </t>

  <t><list style="symbols">
   <t>Direct connection between a DOC client and a DOC server</t>
   <t>DOC client --- non-DOC agent --- DOC server</t>
   <t>DOC client --- DOC agent --- DOC server</t>
   <t>Non-DOC client --- DOC agent --- DOC server</t>
   <t>Non-DOC client --- DOC agent --- Mix of DOC and non-DOC servers</t>
   <t>DOC client --- agent --- Partitioned/Segmented DOC server</t>
   <t>DOC client --- agent --- agent --- Partitioned/Segmented DOC server</t>
   <t>DOC client --- edge agent --- edge agent --- DOC server</t>
  </list>
  </t>
      
  </section>

  <section title="Diameter Agent Behaviour">
   <t>In the context of the Diameter Overload Indication dissemination and reacting to
    the overload information, the functional behaviour of the Diameter agnets in front
    of servers, especially concerning Diameter proxies, has to be common. This is
    topical since intelligent Diameter agents may actively participate to the
    overload condition handling (such as do intelligent next hop selection based on
    the overload conditions or aggregate overload information to be disseminated).
    Further, Diameter agents
    may also have other deployment related tasks that are not defined in the Diameter
    base protocol <xref target="RFC6733"/>. These include, among others, topology hiding
    and acting as a server representative for a cluster of real Diameter servers for the
    Diameter client. To be efficient, such network topologies imply that the Diameter
    agents in front of servers remain in the Diameter signaling path for all the messages
    related to the same session/user.
   </t>
   <t>Since the solution defined in this specification MUST NOT break the Diameter
    base protocol assumptions at any time, great care has to be taken not to assume
    functionality from the Diameter agents that would, at the base protocol level and
    between two Diameter end nodes break or assume functionality beyond the
    Diameter base protocol. Effectively this means the following from a Diameter agent:
   </t>
   <t>
    <list style="symbols">
    <t>A Diameter agent that impersonates itself as the "end node", i.e. the server to a
     Diameter client MUST NOT leak any Diameter base protocol level information of the
     Diameter nodes behind it. From the Diameter client point of view the final
     destination to its requests and the original source for the answers MUST be the
     Diameter agent. Effectively this requirement means the Diameter agent acts as a
     back-to-back-agent. How the Diameter agent in this case appears to the Diameter
     nodes it is representing (i.e. the real Diameter servers), is an implementation and
     a deployment specific within the realm the Diameter agent is deployed.
    </t>
    
    <t>This requirement also implies that if the Diameter agent is not
     able to impersonate the servers behind it, the Diameter dialogue is always
     established between clients and servers and any overload information received
     by a client would be from a given server identified by the Origin-Host identity.
    </t>
    </list>
   </t>
    
   
  </section>

  <section title="Simplified Example Architecture">
   <t>**Early Draft!**
   </t>

<figure title="Simplified architecture choices for overload indication delivery">
 <artwork><![CDATA[
 Realm X                                  Other Realms
<--------------------------------------> <---------------------->

+--^-----+                 : (optional) :
|Diameter|                 :            :
|Server A|--+     .--.     : +---^----+ :     .--.     
+--------+  |   _(    `.   : |Diameter| :   _(    `.   +---^----+
            +--(        )--:-|  Agent |-:--(        )--|Diameter|
+--------+  | ( `  .  )  ) : +-----^--+ : ( `  .  )  ) | Client |
|Diameter|--+  `--(___.-'  :            :  `--(___.-'  +-----^--+
|Server B|                 :            :
+---^----+                 :            :
            Overload Indication A    Overload Indication A'
       1)  <----------------------> <---------------------->
           standard base protocol   standard base protocol

            End-to-end Overload Indication
       2)  <----------------------------------------------->
                       standard base protocol


]]></artwork></figure>
  </section>


 </section>

 <section title="Clarifications to Diameter Base Protocol">
 <section title="DIAMETER_TOO_BUSY clarifications">
  <t>Describe here, assuming there is a need, what parts of the
   existing Diameter Base Protocol <xref target="RFC6733"/> needs
   clarification in the even of the overload condition.
  </t>
 </section>
</section>

 <section title="Dissemination of the Overload Indication" anchor="piggy">
  <t>Explain, e.g. the piggybacking of Overload Indication AVPs in this
   section. Explain how possible feature negotiation is done?
  </t>
  
  <section title="Negotiation and Versioning">
  </section>

  <section title="Transmission of the Attribute Value Pairs">
  </section>
  
 </section>

 <section title="Overload Condition Indication">
  <t>Describe here what the overload condition indication is about.
  </t>
 </section>

 
</section>

<section title="Attribute Value Pairs" anchor="avps">
 <t>This section describes the encoding and semantics of
  Overload Indication Attribute Value Pairs (AVPs).
 </t>
 <section title="OC-Feature-Vector AVP" anchor="fvec">
  <t>The OC-Feature-Vector AVP (AVP code TBD1) is type of Unsigned64
   and contains a 64 bit flags field of supported capabilities of an
   overload control endpoint. Sending and receiving the OC-Feature-Vector
   AVP with value 0 MUST be supported, although that does not
   provide much guidance about specific capabilities of the endpoint.
 </t>

 <t>An overload control endpoint MAY include this AVP to indicate its
  capabilities to the other overload control endpoint. For example, the
  (client) endpoint may indicate that it support additional traffic
  abatement algoritms than just the implicitly supported default one.
 </t>
 <t>During the message exchange the overload control endpoints express
  their common set of supported capabilities. The endpoint sending a
  request includes the OC-Feature-Vector AVP with those flags set that
  correspont what it supports. The receiver who eventually sends an answer
  includes also the OC-Feature-Vector AVP with those flags set that it
  correspont what can and selected to support with the other endpoint. 
 </t>
 <t>Note that when the OC-Feature-Vector AVP is used together with the
  OC-OLR AVPs, the contents of the announced features and the contents
  of the OC-OLR AVPs MUST NOT contradict each other.
 </t>
 <t>The following capabilities are defined in this document: </t>
  <t><list style="hanging"> 
   <t hangText="OLR_DEFAULT_ALGO (0x0000000000000001)"><vspace blankLines="1"/>
    When this flag is set by the overload control endpoint it means that the
	default traffic abatement (loss) algorithm is suppoorted.
   </t>
  </list>
  </t>
 </section>

 <section title="OC-OLR AVP" anchor="olr">
  <t>The OC-OLR AVP (AVP code TBD2) is type of Grouped and contains the
   necessary information to compose an overload report and/or e.g., indicate
   a set of supported algorithms.
  </t>
  <t>The TimeStamp AVP indicates when the original OC-OLR AVP with the
   current content was created. It is possible to replay the same OC-OLR
   AVP multiple times between the overload endpoints, however, as long as
   the OC-OLR AVP content changes or the other information sending endpoint
   wants the receiving endpoint to update its overload control information,
   then the TimeStamp AVP MUST contain a new value.
  </t>
 
<figure>
<artwork><![CDATA[
OC-OLR ::= < AVP Header: TBD2 >
           < TimeStamp >
           [ ValidityTime ]
           [ ReportType ]
         * [ OC-Algorithm ]
         * [ AVP ]
]]></artwork>
</figure>

 </section>
 
 <section title="TimeStamp AVP" anchor="tstamp">
  <t>The TimeStamp AVP (AVP code TBD3) is type of Time. Its usage
   in the context of the overload control is described in <xref target="olr"/>.
   From the functionality point of view, the TimeStamp AVP is merely
   used as a non-volatile increasing counter between two overload control
   endpoints.
  </t>
 </section>
 
 <section title="ValidityTime AVP" anchor="valid">
  <t>The ValidityTime AVP (AVP code TBD4) is type of Unsigned32 and 
   describes the number of seconds the OC-OLR AVP and its content is
   valid since the creation of the OC-OLR OVP.
  </t>
  <t>A timeout of the overload report has specific conserns that need
   to be taken into account by the endpoint acting on the earlier
   received overload report(s). <xref target="redur"/> discusses the
   impacts of timeout in the scope of the traffic abatement algorithms.
  </t>
  <t>As a general guidance for implementations it is RECOMMENDED never
   let any overload report to timeout. Rather, an overload endpoint
   should explicitly signal, e.g. the end of overload condition. This 
   leaves no room for the other overload endpoint to reason or guess
   the condition the other endpoint is at.
  </t>
 </section>
 
 <section title="ReportType AVP" anchor="rtype">
  <t>The ReportType AVP (AVP code TBD5) is type of Enumerated.
   The value of the AVP describes what the overload report conserns.
   The following values are initially defined:
  </t>
  <t><list style="hanging">
   <t hangText="0">Reserved.</t>
   <t hangText="1">Host originated/concerning report.</t>
   <t hangText="2">Realm concerning (aggregated) report.</t>
  </list>
  </t>
 </section>
 
 <section title="OC-Algorithm AVP" anchor="algo">
  <t>The OC-Algorithm AVP (AVP code TBD6) is type of Grouped. The
   AVP contains the necessary sub-AVPs and information for the use
   for the traffic abatement algorithm. 
  </t>
  <t>This specification defines one default algorithm (see
   <xref target="fvec"/> for the OC-Feature-Vector flag corresponding
   to the algorithm). The default (loss) algorithm
  </t>

<figure>
<artwork><![CDATA[
OC-Algorithm ::= < AVP Header: TBD6 >
                 < Algorithm-ID >
                 { Reduction-Percentage }
               * [ AVP ]
]]></artwork>
</figure>
 </section>
 
 <section title="Algorithm-ID AVP" anchor="alg-id">
  <t>The Algorithm-ID AVP (AVP code TBD7) is type of Enumerated and
   identifies the traffic abatement algorithm the OC-Algorithm AVP
   "describes" and implements. This specification defines the following
   algorithms:
  </t>
  <t><list style="hanging">
   <t hangText="0">Reserved.</t>
   <t hangText="1">Default (loss) algorithm.</t>
  </list>
  </t>
 </section>
 
<section title="Reduction-Percentage AVP" anchor="redur">
  <t>The Reduction-Percentage AVP (AVP code TBD8) is type of Unsigned32 and
   describes the percentage of the traffic (compared to the earlier,
   determined by the information sender) what the sender of this
   percentage information is expecting to receive in the future. 
  </t>
  <t>The value of the Reduction-Percentage AVP is between zero (0)
   and one hundred (100). Values greater than 100 are interpreted as
   100. The value of 100 means that no traffic is expected, i.e. the
   sender of the information is under a severe load and ceases to
   process any new messages. The value of 0 means that the sender of
   the information is in a stable state and has no requests to the
   other endpoint to apply any traffic abatement.
  </t>
  <t>If an overload control endpoint comes out of the 100 percent
   traffic reduction as a result of the overload report timing out,
   the following concerns are RECOMMENDED to be applied. The endpoint
   sending the traffic should be conservative and, for example, first 
   send few "probe" messages to learn the overload condition of the
   other endpoint before converging to any traffic amount/rate 
   decided by the sender. Similar concerns actually apply in all
   cases when the overload report times out unless the previous 
   overload report stated 0 percent reduction.
  </t>
 </section>
 
 <section title="Attribute Value Pair flag rules">
  <figure><artwork><![CDATA[
                                                   +---------+
                                                   |AVP flag |
                                                   |rules    |
                                                   +----+----+
                   AVP   Section                   |    |MUST|
 Attribute Name    Code  Defined  Value Type       |MUST| NOT|
+--------------------------------------------------+----+----+
|OC-Feature-Vector TBD1  x.x      Unsigned64       |    | V  |
+--------------------------------------------------+----+----+
|OC-OLR            TBD2  x.x      Grouped          |    | V  |
+--------------------------------------------------+----+----+
|TimeStamp         TBD3  x.x      Time             |    | V  |
+--------------------------------------------------+----+----+
|ValidityTime      TBD4  x.x      Unsigned32       |    | V  |
+--------------------------------------------------+----+----+
|ReportType        TBD5  x.x      Enumerated       |    | V  |
+--------------------------------------------------+----+----+
|OC-Algorithm      TBD6  x.x      Grouped          |    | V  |
+--------------------------------------------------+----+----+
|Algorithm-ID      TBD7  x.x      Enumerated       |    | V  |
+--------------------------------------------------+----+----+
|Reduction                                         |    |    |
|  -Percentage     TBD8  x.x      Unsigned32       |    | V  |
+--------------------------------------------------+----+----+
]]></artwork></figure>
 </section>
</section>

<section title="Overload Control Operation" anchor="proto">
 <section title="Overload Control Endpoints">
 </section>

 <section title="Piggybacking Principle">
 </section>

 <section title="Capability Negotiation">
 </section>

 <section title="Protocol Extensibility" anchor="ext">
 </section>

 <section title="Overload Report Processing">
  <section title="Sender Endpoint Considerations">
  </section>

  <section title="Receiver Endpoint Considerations">
  </section>
 </section>
</section>

<section title="Transport Considerations" anchor="transport">
 <t>In order to reduce overload control introduced additional AVP
  and message processing it might be desirable/beneficial to signal
  whether the Diameter command carries overload control information
  that should be of interest of an overload aware Diameter node.
 </t>
 <t>Should such indication be include is not part of this
  specification. It has not either been concluded at what layer
  such possible indication should be. Obvious candidates 
  include transport layer protocols (e.g., SCTP PPID or
  TCP flags) or Diameter command header flags.
 </t>
</section>


<section title="IANA Considerations" anchor="iana">
 <section title="AVP codes">
  <t>New AVPs defined by this specification are listed in <xref target="avps"/>.
   All AVP codes allocated from the  'Authentication,  Authorization, and
   Accounting (AAA) Parameters' AVP Codes registry.
  </t>
 </section>
 <!--section title="Result-Code values">
  <t>This specification adds...:
  </t>
  <figure><artwork><![CDATA[
AVP Values | Attribute Name                | Reference
-----------+-------------------------------+----------
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
]]></artwork></figure>
 </section-->
 <section title="New registries">
 <t>Three new registries are needed under the 'Authentication,  Authorization, 
  and Accounting (AAA) Parameters' registry.
 </t>
 <t><xref target="fvec"/> defines a new
  "Overload Control Feature Vector" registry including the initial assignments.
  New values can be added into the registry using the Specification Required
  policy <xref target="RFC5226"/>.
 </t>
 <t><xref target="rtype"/> defines a new "Overload Report Type" registry with
  its initial assignments. New types can be added using the Specification
  Required policy <xref target="RFC5226"/>.
 </t>
 <t><xref target="alg-id"/> defines a new "Overload Control Algorith" registry
  with its initial assignments. New types can be added using the Specification
  Required policy <xref target="RFC5226"/>.
 </t>
 </section>
</section>

<section title="Security Considerations">
 <t>No end to end security. We need to live with that.
 </t>
</section>

<section title="Design Team Members">
 <t>This document is a product of the following Diameter Overload Control Design Team
  members:
 </t>
 <t><list style="symbols">
  <t>Ben Campbell</t>
  <t>Eric McMurry</t>
  <t>Hannes Tschofenig</t>
  <t>Jean-Jacques Trottin</t>
  <t>Jouni Korhonen</t>
  <t>Lionel Morand</t>
  <t>Maria Cruz Bartolome</t>
  <t>Martin Dolly</t>
  <t>Nirav Salot</t>
  <t>Steve Donovan</t>
  <t>Susan Shishufeng</t>
 </list>
 </t>
</section>


<section title="Acknowledgements">
 <t>...
 </t>
</section>


</middle>

    <!-- ====================================================================== -->

<back>
 <references title="Normative References">
  &RFC2119;
  &RFC6733;
  &RFC5226;
 </references>

 <references title="Informative References">
  &I-D.ietf-dime-overload-reqs;
  &RFC4006;
 </references>

    <!-- ====================================================================== -->
 <section title="Issues left for future specifications" anchor="ffs">
  <t>The base solution for the overload control does not cover all
   possible use cases. A number of solution aspects were intentionally
   left for future specification and protocol work.
  </t>
  
  <section title="Additional traffic abatement algorithms">
   <t>This specification describes only means for a simple
    loss based algorithm. Future algorithms can be added using the
	designed solution extension mechanism. The new algorithms
	need to be registered with IANA. See Sections <xref target="fvec"
	format="counter"/>, <xref target="alg-id" format="counter"/> and
	<xref target="iana" format="counter"/> for the required IANA steps. 
   </t>
  </section>
 </section>


<section title="Examples">
  <section title="3GPP S6a interface overload indication">
   <t>Would cover S6a MME-HSS communication with several topology
    choices (such as with or without DRA, and with "generic" agents).
   </t>
  </section>

  <section title="3GPP PCC interfaces overload indication">
   <t>Would cover Gx/Rx and maybe S9.. 
   </t>
  </section>
 </section>



</back>
</rfc>
