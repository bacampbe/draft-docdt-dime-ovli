<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'> 
<!ENTITY RFC2234 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2234.xml'>     
<!ENTITY RFC3588 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml'>     
<!ENTITY RFC4005 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4005.xml'> 
<!ENTITY RFC4072 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml'> 
<!ENTITY RFC3748 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml'> 
<!ENTITY RFC4282 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml'> 
<!ENTITY RFC4284 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4284.xml'> 
<!ENTITY RFC4283 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4283.xml'> 
<!ENTITY RFC2486 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2486.xml'> 
<!ENTITY RFC2865 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml'> 
<!ENTITY RFC5113 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5113.xml'> 
<!ENTITY RFC1034 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'> 
<!ENTITY RFC1035 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml'> 
<!ENTITY RFC3490 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml'> 
<!ENTITY RFC6408 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6408.xml'> 
<!ENTITY RFC6733 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6733.xml'> 
<!ENTITY RFC5226 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'> 
<!ENTITY RFC4006 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4006.xml'>


<!ENTITY I-D.ietf-dime-overload-reqs PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dime-overload-reqs-13.xml'>
<!ENTITY I-D.ietf-dime-e2e-sec-req PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dime-e2e-sec-req-00.xml'>
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?><?rfc subcompact="no" ?>
<rfc ipr="trust200902"

    category="std"
     docName="draft-docdt-dime-ovli-00.txt">
  <front>
    <title abbrev="Diameter Overload Indication">Diameter Overload Indication</title>

    <author role="editor" initials="J" surname="Korhonen" fullname="Jouni Korhonen">
      <organization>Broadcom Communications</organization>
         <address>
                <postal>
                    <street>Porkkalankatu 24</street>
                    <city>Helsinki</city>
                    <code>FIN-00180</code>
                    <country>Finland</country>
                </postal>
                <email>jouni.nospam@gmail.com</email>
            </address>
    </author>

    <author initials="S" surname="Donovan" fullname="Steve Donovan">
      <organization>Oracle</organization>
         <address>
                <postal>
                    <street>17210 Campbell Road</street>
                    <city>Dallas</city>
                    <region>Texas</region>
                    <code>75254</code>
                    <country>United States</country>
                </postal>
                <email>srdonovan@usdonovans.com</email>
            </address>
    </author>

    <date year="2013"/>
    <area>Operations and Management</area>
    <workgroup>Diameter Maintenance and Extensions (DIME)</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Diameter</keyword>
    <keyword>Overload</keyword>
<abstract>
 <t>This specification documents a Diameter Overload Control base solution and
  the dissemination of the overload report information.
      </t>
    </abstract>

  <note title="Requirements">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref
   target="RFC2119">RFC 2119</xref>.
   </t>
  </note>
 </front>
 
<middle>

<section title="Introduction" anchor="intro">
 <t>This specification defines a base solution for the Diameter Overload
  Control. The requirements for the solution are described and discussed
  in the corresponding design requirements document <xref
  target="I-D.ietf-dime-overload-reqs"/>. Note that the overload
  control solution  defined in this specification does not address all
  the requirements listed in <xref target="I-D.ietf-dime-overload-reqs"/>.
  A number of overload control related features are left for the
  future specifications. See <xref target="ffs"/> for more detailed
  discussion on those.
 </t>
</section>

<section title="Terminology and Abbreviations" anchor="abbrev">

 <t><list style="hanging">
 <t hangText="Server Farm"><vspace blankLines="1"/>
 A set of Diameter servers that can handle any request for a given Diameter applications.  While these servers support the same set of applications, they do not necessarily all have the same capacity.  An individual server farm might also support a subset of the users for a Diameter Realm. </t>
 
 <t hangText="Server Front End"><vspace blankLines="1"/>
 A Server Front End (SFE) is a role that can be performed by a Diameter agent -- either a relay or a proxy -- that sits between Diameter clients and a Server Farm. An SFE can perform various functions for the server farm it sits in front of.  This includes some or all of the following functions:
 <list style="symbols">
     <t>Diameter Routing</t>
     <t>Diameter layer load balancing</t>
     <t>Load Management</t>
     <t>Overload Management</t>
     <t>Topology Hiding</t>
     <t>Server Farm Identity Management</t>
 </list>
 </t>

 <t hangText="Diameter Routing"><vspace blankLines="1"/>
  Routing of Diameter messages addressed to either a Diameter Realm or a
  specific Diameter-Host.  This function is defined in <xref target="RFC6733"/>.
  Application level routing specifications that expand on <xref target="RFC6733"/>
  also exist.</t>
 
 <t hangText="Diameter-layer Load Balancing"><vspace blankLines="1"/>
  Diameter layer load balancing allows Diameter requests to be distributed across
  the set of servers. Definition of this function is outside the scope of this
  document. </t>
 
 <t hangText="Load Management"><vspace blankLines="1"/>
  This functionality ensures that the consolidated load state for the
  server farm is collected, and processed. The exact algorithm for computing
  the load at the SFE is implementation specific but enough semantic of the
  conveyed load information needs to be specified so that deterministic
  behavior can be ensured. </t>
 
 <t hangText="Overload Management"><vspace blankLines="1"/>
  The SFE is the entity that understands the consolidated overload state
  for the server farm.  Just as it is outside the scope of this document
  to specify how a Diameter server calculates its overload state, it is
  also outside the scope of this document to specify how an SFE calculates
  the overload state for the set of servers.  This document describes how
  the SFE communicates Overload information to Diameter Clients. </t>

 <t hangText="Topology Hiding"><vspace blankLines="1"/>
  Topology Hiding is loosely defined as ensuring that no Diameter topology
  information about the server farm can be discovered from Diameter messages
  sent outside a predefined boundary (typically administrative domain).  This
  includes obfuscating identifiers and address information of Diameter entities
  in the server farm.  It can also include hiding the number of various Diameter
  entities in the server farm.  Identifying information can occur in many
  Diameter AVPs, including Origin-Host, Destination-Host, Route-Record,
  Proxy-Info, Session-ID and other AVPs.
 </t>
 
 <t hangText="Server Farm Identity Management"><vspace blankLines="1"/>
  Server Farm Identity Management (SFIM) is a mechanism that can be used by
  the SFE to present a single Diameter identity that can be used by clients
  to send Diameter requests to the server farm.  This requires that the SFE
  modifies Origin-Host information in answers coming from servers in the
  server farm. An agent that performs SFIM appears as a server from the
  client's perspective. </t>
</list>
</t>
</section>


<section title="Solution Overview">
 <section title="Architectural Assumptions">
  <t>Describe here on what basis the solution is intended to work. This lists 
  things like piggybacking, end-to-end semantics, role of Diameter agents, etc.
  </t>
  
  <section title="Application Classification">
   <t>The following is a classification of Diameter applications and requests. 
    This discussion is meant to document factors that play into decisions made
    by the Diameter identity responsible for handling overload reports.
   </t>

   <t>Section 8.1 of <xref target="RFC6733"/> defines two state machines that imply two
    types of applications, session-less and session-based.  The primary differentiator
	between these types of applications is the lifetime of Session-IDs.  
   </t>

   <t>For session-based applications, the session-id is used to tie multiple requests into
    a single session.  
   </t>

   <t>In session-less applications, the lifetime of the session-id is a single Diameter
    transaction.
   </t>

   <t>The 3GPP-defined S6a application is an example of a session-less application.
    The following, copied from section 7.1.4 of 29.272, explicitly states that
    sessions are implicitly terminated and that the server does not maintain session state:
   </t>

   <t><list>
    <t>"Between the MME and the HSS and between the SGSN and the HSS and between the MME
     and the EIR, Diameter sessions shall be implicitly terminated. An implicitly
     terminated session is one for which the server does not maintain state information.
     The client shall not send any re-authorization or session termination requests to
     the server.
    </t>
    <t>The Diameter base protocol includes the Auth-Session-State AVP as the mechanism for
     the implementation of implicitly terminated sessions.
    </t>
    <t>The client (server) shall include in its requests (responses) the Auth-Session-State
     AVP set to the value NO_STATE_MAINTAINED (1), as described in <xref target="RFC6733"/>.
     As a consequence, the server shall not maintain any state information about this
     session and the client shall not send any session termination request. Neither the
     Authorization-Lifetime AVP nor the Session-Timeout AVP shall be present in requests
     or responses."
    </t>
   </list>
   </t>

   <t>For the purposes of this discussion, session-less applications are further divided
    into two types of applications:
   </t>

   <t><list style="hanging">
    <t hangText="Stateless applications"> Requests within a stateless application have no
     relationship to each other.  The 3GPP defined S13 application is an example
     of a stateless application.
    </t>
    <t hangText="Pseudo-session applications"> While this class of application does not use the
     Diameter Session-ID AVP to correlate requests, there is an implied ordering of
     transactions defined by the application.  The 3GPP defined Cx application is an
     example of a pseudo-session application.
    </t>
   </list>
   </t>

   <t>The accounting application defined in <xref target="RFC6733"/> and the
    Credit-Control application defined in <xref target="RFC4006"/> are examples
	of Diameter session-based applications.
   </t>
   <t>The handling of overload reports must take the type of application into
    consideration, as discussed in section xxxxx.
   </t>
  </section>
  
  <section title="Application Type Overload Implications">

  <t>This section discusses considerations for mitigating overload reported by a Diameter
   entity.  This discussion focuses on the type of application.  Section xxxx discussion
   considerations for handling various request types when the target server is known to
   be in an overloaded state.  Section xxxx discusses considerations for handling
   overload conditions based on the network deployment scenario.
  </t>
  <t>These discussions assume that the strategy for mitigating the reported overload is
   to reduce the overall workload on the overloaded entity.  The concept of applying
   overload treatment to requests targeted for an overloaded Diameter entity is inherent
   to this discussion.  The overload treatment is not specified here but could include
   routing the request to another Diameter entity known to be able to handle the request.
   Overload treatment could also include rejecting the request.  For a Diameter agent,
   rejecting a request will generally mean rejecting could be generating an appropriate
   Diameter error response   For a Diameter client, rejecting the request could mean
   giving an indication to the entity requesting the Diameter service that the network
   is busy and to try again later.
  </t>
  <t><list style="hanging">
   <t hangText="Stateless applications"> By definition there is no relationship between individual
   requests in a stateless application.  As a result, when a request is sent or relayed
   to an overloaded Diameter entity - either a Diameter Server or a Diameter Agent
   - the sending/relaying entity can choose to apply overload treatment to any request
   targeted for the overloaded entity.
  </t>
  <t hangText="Pseudo stateful applications"> Pseudo stateful applications are also stateless
   applications in that there is no session Diameter state maintained between
   transactions.  There is, however, an implied ordering of requests.  As a result,
   decisions about which transactions to reject as a result of an overloaded entity
   could/should take the command-code of the request into consideration.  This generally
   means that transactions later in the sequence of transactions should be given more
   favorable treatment than messages earlier in the sequence.   This is because more
   work has already been done by the Diameter network for those transactions that
   occur later in the sequence.  Rejecting them could result in increasing the load
   on the network as the transactions earlier in the sequence might also need to be
   repeated.
  </t>
  <t hangText="Stateful applications"> Overload handling for stateful applications must take into
   consideration the work associated with setting up an maintaining a session.  As such,
   the entity handling overload of a Diameter entity for a stateful application might
   tend to reject new session requests before rejecting intra-session requests.  In
   addition, session ending requests might be given a lower priority of being rejected
   as rejecting session ending requests could result in session status being out of
   sync between the Diameter clients and servers.
  </t></list>
  </t>
  </section>
  <section title="Request Transaction Classification">
   <t><list style="hanging">
   <t hangText="Independent Request">An independent request is not a part of a Diameter session and,
    as such, the lifetime of the session-id is constrained to an individual transaction.  
   </t>
   <t hangText="Session-Initiating Request"> A session-initiating request is the initial message
    that establishes a Diameter session.  The ACR message defined in
    <xref target="RFC6733"/> is an example of a session-initiating request.
   </t>
   <t hangText="Correlated Session-Initiating Request"> There are cases, most notably in the 3GPP
    PCC architecture, where multiple Diameter sessions are correlated and must be handled
    by the same Diameter server.  This is a special case of a Session-Initiating Request.
    Gx CCR-I requests and Rx AAR messages are examples of correlated session-initiating
    requests.
   </t>
   <t hangText="Intra-Session Request"> An intra session request is a request that uses a
    session-id for an already established request.  An intra session request generally
    needs to be delivered to the server that handled the session creating request for
    the session.  The STR message defined in RFC 6733 is an example of an intra-session
    requests.  CCR-U and CCR-T requests defined in RFC4006 are further examples of
    intra-session requests.
   </t>
   <t hangText="Pseudo-Session Requests"> Pseudo session requests are independent requests and,
    as such, the request transactions are not tied together using the Diameter
    session-id.  There exist Diameter applications that define an expected ordering
    of transactions.  This sequencing of independent transactions results in a pseudo
    session.  The AIR, MAR and SAR requests in the 3GPP defined Cx application are
    examples of pseudo-session requests.
   </t>   
   </list>
   </t>
  </section>
  
  <section title="Request Type Overload Implications">
   <t>Independent requests - Independent requests can be given equal treatment when
    making throttling decisions.
   </t>
   <t>Session-creating requests – Session-creating requests represent more work than
    independent or intra-session requests.   As such, throttling decisions might
    favor intra-session requests over session-creating requests.  Individual
    session-creating requests can be given equal treatment when making throttling
    decisions.
   </t>
   <t>Correlated session-creating requests – Requests that result in a new binding,
    where the binding is used for routing of subsequent session-creating requests,
    represent more work than all other requests.  As such, these requests might be
    throttled more frequently than other request types.
   </t>
   <t>Pseudo-session requests – Throttling decisions for pseudo-session requests can
    take where individual requests fit into the overall sequence of requests within
    the pseudo session.  Requests that are earlier in the sequence might be throttled
    more aggressively than requests that occur later in the sequence.
   </t>
   <t>Intra-session requests – There are two classes of intra-sessions requests.
    The first is a request that ends a session.  The second is a request that is
    used to convey session related state between the Diameter client and server. 
    Session ending request should be throttled less aggressively in order to keep
    session state consistent between the client and server.  The default handling
    of other intra-session requests might be to treat them equally when making
    throttling decisions.   There might also be application level considerations
    whether some request types are favored over others.
   </t>   
  </section>
  
  <section title="Diameter Deployment Scenarios">
   <t>This section discusses various Diameter network deployment scenarios and the
    implications of those deployment models on handling of overload reports.
   </t>
   <t>The scenarios vary based on the following:
   </t>

   <t><list style="symbols">
    <t>The presence or absence of Diameter agents</t>
    <t>Which Diameter entities support the DOC extension</t>
    <t>The amount of the network topology understood by Diameter clients</t>
    <t>The complexity of the Diameter server deployment for a Diameter application</t>
    <t>Number of Diameter applications supported by Diameter clients and Diameter
     servers</t>
   </list>
   </t>

   <t>Without consideration for which elements support the DOC extension, the following
    is a representative list of deployment scenarios:
   </t>

  <t><list style="symbols">
   <t>Client --- Server</t>
   <t>Client --- Multiple equivalent servers</t>
   <t>Client --- Agent --- Multiple equivalent servers</t>
   <t>Client --- Agent [ --- Agent ] --- Partitioned server</t>
   <t>Client --- Edge Agent [ --- Edge Agent] ---
    { Multiple Equivalent Servers | Partitioned Servers }</t>
   <t>Client --- Session Correlating Agent --- Multiple Equivalent Servers</t>
  </list>
  </t>

  <t>The following is a list of representative deployment scenarios:
  </t>

  <t><list style="symbols">
   <t>Direct connection between a DOC client and a DOC server</t>
   <t>DOC client --- non-DOC agent --- DOC server</t>
   <t>DOC client --- DOC agent --- DOC server</t>
   <t>Non-DOC client --- DOC agent --- DOC server</t>
   <t>Non-DOC client --- DOC agent --- Mix of DOC and non-DOC servers</t>
   <t>DOC client --- agent --- Partitioned/Segmented DOC server</t>
   <t>DOC client --- agent --- agent --- Partitioned/Segmented DOC server</t>
   <t>DOC client --- edge agent --- edge agent --- DOC server</t>
  </list>
  </t>
      
  </section>

  <section title="Diameter Agent Behaviour">
   <t>In the context of the Diameter Overload Indication dissemination and reacting to
    the overload information, the functional behaviour of the Diameter agents in front
    of servers, especially concerning Diameter proxies, has to be common. This is
    topical since intelligent Diameter agents may actively participate to the
    overload condition handling (such as do intelligent next hop selection based on
    the overload conditions or aggregate overload information to be disseminated).
    Further, Diameter agents
    may also have other deployment related tasks that are not defined in the Diameter
    base protocol <xref target="RFC6733"/>. These include, among others, topology hiding
    and acting as a server representative for a cluster of real Diameter servers for the
    Diameter client. To be efficient, such network topologies imply that the Diameter
    agents in front of servers remain in the Diameter signaling path for all the messages
    related to the same session/user.
   </t>
   <t>Since the solution defined in this specification MUST NOT break the Diameter
    base protocol assumptions at any time, great care has to be taken not to assume
    functionality from the Diameter agents that would, at the base protocol level and
    between two Diameter end nodes break or assume functionality beyond the
    Diameter base protocol. Effectively this means the following from a Diameter agent:
   </t>
   <t>
    <list style="symbols">
    <t>A Diameter agent that impersonates itself as the "end node", i.e. the server to a
     Diameter client MUST NOT leak any Diameter base protocol level information of the
     Diameter nodes behind it. From the Diameter client point of view the final
     destination to its requests and the original source for the answers MUST be the
     Diameter agent. Effectively this requirement means the Diameter agent acts as a
     back-to-back-agent. How the Diameter agent in this case appears to the Diameter
     nodes it is representing (i.e. the real Diameter servers), is an implementation and
     a deployment specific within the realm the Diameter agent is deployed.
    </t>
    
    <t>This requirement also implies that if the Diameter agent is not
     able to impersonate the servers behind it, the Diameter dialogue is always
     established between clients and servers and any overload information received
     by a client would be from a given server identified by the Origin-Host identity.
    </t>
    </list>
   </t>
    
   
  </section>

  <section title="Simplified Example Architecture">

<figure title="Simplified architecture choices for overload indication delivery">
 <artwork><![CDATA[
 Realm X                                  Other Realms
<--------------------------------------> <---------------------->

+--^-----+                 : (optional) :
|Diameter|                 :            :
|Server A|--+     .--.     : +---^----+ :     .--.     
+--------+  |   _(    `.   : |Diameter| :   _(    `.   +---^----+
            +--(        )--:-|  Agent |-:--(        )--|Diameter|
+--------+  | ( `  .  )  ) : +-----^--+ : ( `  .  )  ) | Client |
|Diameter|--+  `--(___.-'  :            :  `--(___.-'  +-----^--+
|Server B|                 :            :
+---^----+                 :            :
            Overload Indication A    Overload Indication A'
       1)  <----------------------> <---------------------->
           standard base protocol   standard base protocol

            End-to-end Overload Indication
       2)  <----------------------------------------------->
                       standard base protocol


]]></artwork></figure>
  </section>


 </section>

 <section title="Clarifications to Diameter Base Protocol">
 <section title="DIAMETER_TOO_BUSY clarifications">
  <t>Describe here, assuming there is a need, what parts of the
   existing Diameter Base Protocol <xref target="RFC6733"/> needs
   clarification in the even of the overload condition.
  </t>
 </section>
</section>

 <section title="Dissemination of the Overload Indication" anchor="piggy">
  <t>Explain, e.g. the piggybacking of Overload Indication AVPs in this
   section. Explain how possible feature negotiation is done?
  </t>
  
  <section title="Negotiation and Versioning">
  </section>

  <section title="Transmission of the Attribute Value Pairs">
  </section>
  
 </section>

 <section title="Overload Condition Indication">
  <t>Describe here what the overload condition indication is about.
  </t>
 </section>

 
</section>

<section title="Attribute Value Pairs" anchor="avps">
 <t>This section describes the encoding and semantics of
  Overload Indication Attribute Value Pairs (AVPs).
 </t>
 <section title="OC-Feature-Vector AVP" anchor="fvec">
  <t>The OC-Feature-Vector AVP (AVP code TBD1) is type of Unsigned64
   and contains a 64 bit flags field of supported capabilities of an
   overload control endpoint. Sending and receiving the OC-Feature-Vector
   AVP with value 0 MUST be supported, although that does not
   provide much guidance about specific capabilities of the endpoint.
 </t>

 <t>An overload control endpoint MAY include this AVP to indicate its
  capabilities to the other overload control endpoint. For example, the
  (client) endpoint may indicate that it support additional traffic
  abatement algorithms than just the implicitly supported default one.
 </t>
 <t>During the message exchange the overload control endpoints express
  their common set of supported capabilities. The endpoint sending a
  request includes the OC-Feature-Vector AVP with those flags set that
  correspond what it supports. The receiver who eventually sends an answer
  includes also the OC-Feature-Vector AVP with those flags set that it
  correspond what can and selected to support with the other endpoint. 
 </t>
 <t>Note that when the OC-Feature-Vector AVP is used together with the
  OC-OLR AVPs, the contents of the announced features and the contents
  of the OC-OLR AVPs MUST NOT contradict each other.
 </t>
 <t>The following capabilities are defined in this document: </t>
  <t><list style="hanging"> 
   <t hangText="OLR_DEFAULT_ALGO (0x0000000000000001)"><vspace blankLines="1"/>
    When this flag is set by the overload control endpoint it means that the
	default traffic abatement (loss) algorithm is supported.
   </t>
  </list>
  </t>
 </section>

 <section title="OC-OLR AVP" anchor="olr">
  <t>The OC-OLR AVP (AVP code TBD2) is type of Grouped and contains the
   necessary information to compose an overload report and/or e.g., indicate
   a set of supported algorithms.
  </t>
  <t>The TimeStamp AVP indicates when the original OC-OLR AVP with the
   current content was created. It is possible to replay the same OC-OLR
   AVP multiple times between the overload endpoints, however, as long as
   the OC-OLR AVP content changes or the other information sending endpoint
   wants the receiving endpoint to update its overload control information,
   then the TimeStamp AVP MUST contain a new value.
  </t>
 
<figure>
<artwork><![CDATA[
OC-OLR ::= < AVP Header: TBD2 >
           < TimeStamp >
           [ ValidityTime ]
           [ ReportType ]
         * [ OC-Algorithm ]
         * [ AVP ]
]]></artwork>
</figure>

 </section>
 
 <section title="TimeStamp AVP" anchor="tstamp">
  <t>The TimeStamp AVP (AVP code TBD3) is type of Time. Its usage
   in the context of the overload control is described in <xref target="olr"/>.
   From the functionality point of view, the TimeStamp AVP is merely
   used as a non-volatile increasing counter between two overload control
   endpoints.
  </t>
 </section>
 
 <section title="ValidityTime AVP" anchor="valid">
  <t>The ValidityTime AVP (AVP code TBD4) is type of Unsigned32 and 
   describes the number of seconds the OC-OLR AVP and its content is
   valid since the creation of the OC-OLR AVP.
  </t>
  <t>A timeout of the overload report has specific concerns that need
   to be taken into account by the endpoint acting on the earlier
   received overload report(s). <xref target="redur"/> discusses the
   impacts of timeout in the scope of the traffic abatement algorithms.
  </t>
  <t>As a general guidance for implementations it is RECOMMENDED never
   let any overload report to timeout. Rather, an overload endpoint
   should explicitly signal, e.g. the end of overload condition. This 
   leaves no room for the other overload endpoint to reason or guess
   the condition the other endpoint is at.
  </t>
 </section>
 
 <section title="ReportType AVP" anchor="rtype">
  <t>The ReportType AVP (AVP code TBD5) is type of Enumerated.
   The value of the AVP describes what the overload report concerns.
   The following values are initially defined:
  </t>
  <t><list style="hanging">
   <t hangText="0">Reserved.</t>
   <t hangText="1">Host originated/concerning report.</t>
   <t hangText="2">Realm concerning (aggregated) report.</t>
  </list>
  </t>
 </section>
 
 <section title="OC-Algorithm AVP" anchor="algo">
  <t>The OC-Algorithm AVP (AVP code TBD6) is type of Grouped. The
   AVP contains the necessary sub-AVPs and information for the use
   for the traffic abatement algorithm. 
  </t>
  <t>This specification defines one default algorithm (see
   <xref target="fvec"/> for the OC-Feature-Vector flag corresponding
   to the algorithm). The default (loss) algorithm
  </t>

<figure>
<artwork><![CDATA[
OC-Algorithm ::= < AVP Header: TBD6 >
                 < Algorithm-ID >
                 { Reduction-Percentage }
               * [ AVP ]
]]></artwork>
</figure>
 </section>
 
 <section title="Algorithm-ID AVP" anchor="alg-id">
  <t>The Algorithm-ID AVP (AVP code TBD7) is type of Enumerated and
   identifies the traffic abatement algorithm the OC-Algorithm AVP
   "describes" and implements. This specification defines the following
   algorithms:
  </t>
  <t><list style="hanging">
   <t hangText="0">Reserved.</t>
   <t hangText="1">Default (loss) algorithm.</t>
  </list>
  </t>
 </section>
 
<section title="Reduction-Percentage AVP" anchor="redur">
  <t>The Reduction-Percentage AVP (AVP code TBD8) is type of Unsigned32 and
   describes the percentage of the traffic (compared to the earlier,
   determined by the information sender) what the sender of this
   percentage information is expecting to receive in the future. 
  </t>
  <t>The value of the Reduction-Percentage AVP is between zero (0)
   and one hundred (100). Values greater than 100 are interpreted as
   100. The value of 100 means that no traffic is expected, i.e. the
   sender of the information is under a severe load and ceases to
   process any new messages. The value of 0 means that the sender of
   the information is in a stable state and has no requests to the
   other endpoint to apply any traffic abatement.
  </t>
  <t>If an overload control endpoint comes out of the 100 percent
   traffic reduction as a result of the overload report timing out,
   the following concerns are RECOMMENDED to be applied. The endpoint
   sending the traffic should be conservative and, for example, first 
   send few "probe" messages to learn the overload condition of the
   other endpoint before converging to any traffic amount/rate 
   decided by the sender. Similar concerns actually apply in all
   cases when the overload report times out unless the previous 
   overload report stated 0 percent reduction.
  </t>
 </section>
 
 <section title="Attribute Value Pair flag rules">
  <figure><artwork><![CDATA[
                                                   +---------+
                                                   |AVP flag |
                                                   |rules    |
                                                   +----+----+
                   AVP   Section                   |    |MUST|
 Attribute Name    Code  Defined  Value Type       |MUST| NOT|
+--------------------------------------------------+----+----+
|OC-Feature-Vector TBD1  x.x      Unsigned64       |    | V  |
+--------------------------------------------------+----+----+
|OC-OLR            TBD2  x.x      Grouped          |    | V  |
+--------------------------------------------------+----+----+
|TimeStamp         TBD3  x.x      Time             |    | V  |
+--------------------------------------------------+----+----+
|ValidityTime      TBD4  x.x      Unsigned32       |    | V  |
+--------------------------------------------------+----+----+
|ReportType        TBD5  x.x      Enumerated       |    | V  |
+--------------------------------------------------+----+----+
|OC-Algorithm      TBD6  x.x      Grouped          |    | V  |
+--------------------------------------------------+----+----+
|Algorithm-ID      TBD7  x.x      Enumerated       |    | V  |
+--------------------------------------------------+----+----+
|Reduction                                         |    |    |
|  -Percentage     TBD8  x.x      Unsigned32       |    | V  |
+--------------------------------------------------+----+----+
]]></artwork></figure>
 </section>
</section>

<section title="Overload Control Operation" anchor="proto">
 <section title="Overload Control Endpoints">
  <t>The overload control solution can be considered as an overlay
   on top of an arbitrary Diameter network. The overload control
   "connection" or rather two Diameter nodes exchanging overload
   control information are called "overload control endpoints".
   These endpoints do not need to be adjacent Diameter peer nodes,
   nor they need to be the end-to-end Diameter nodes in a typical
   "client-server" deployment with multiple intermediate Diameter
   agent nodes in between. The overload control endpoint are the two
   Diameter nodes that decide to exchange overload control information
   between each other. How the endpoints are determined is specific
   to a deployment, a Diameter node role in that deployment and
   local configuration.
  </t>
  <t><list>
   <t>[Editor's note: a picture illustrating the endpoint concept
    would be useful.]
   </t>
  </list>
  </t>
</section>

 <section title="Piggybacking Principle">
  <t>The overload control solution defined AVPs are essentially piggybacked
   on top of existing application message exchanges. This is made
   possible by adding overload control top level AVPs, the OC-OLR AVP
   and the OC-Feature-Vector AVP into existing commands (this has an
   assumption that the application CCF allows adding new AVPs into the
   Diameter messages.
  </t>
  <t>In a case of newly defined Diameter applications, it is RECOMMENDED
   to add and defined how overload control mechanisms works on that
   application.
  </t>
  <t>Note that the overload control solution does not have fixed server
   and client roles. The endpoint role is determined based on the sent
   message type: whether the message is a request or an answer. Furthermore,
   it is always possible that a request message initiating endpoint also 
   includes its own overload report information into the OC-OLR AVP.
   This is an optimization (and beneficial) in cases where the endpoints
   truly use some Diameter application in a bi-directional manner.
  </t>
 </section>

 <section title="Capability Negotiation">
  <t>Since the overload control solution relies on the piggybacking
   principle for the overload reporting and the overload control
   endpoint are likely not adjacent peers, finding out whether the
   other endpoint supports the overload control or what is the common
   traffic abatement algorithm to apply for the traffic. The approach
   defined in this specification for the end-to-end capability 
   negotiation or rather the capability announcement relies on the
   exchange of the OC-Feature-Vector and OC-OLR AVPs between the
   endpoints. The negotiation solution also works when carried out
   on existing applications. For the newly defines application the
   negotiation can be more exact based on the application specification.
   The negotiated set of capabilities MUST NOT change during the life
   time of the Diameter session (or transaction in a case of non-session
   maintaining applications).
  </t>
  <t>It should be noted that the 
  </t>
  <section title="Request Message Initiator Endpoint Considerations" anchor="nego">
   <t>The basic principle is that the request message initiating endpoint
    announces its support for the overload control mechanism by including in the
    request message the OC-Feature-Vector AVP with those capability flag
    bits set that it supports and is willing to use for this Diameter
    session (or transaction in a case of a non-session state maintaining
    applications). In a case of session maintaining applications the
    request message initiating endpoint does not need to do the capability
    announcement more than once. In a case of non-session maintaining
    applications, it is RECOMMENDED that the request message initiating
    endpoint includes the capability announcement into every request regardless
    it has had prior message exchanges with the give remote endpoint.
   </t>
   <t>If the OC-Feature-Vector AVP does not have enough information about the
    supported feature or the traffic abatement algorithm, then the request
    message initiating endpoint MUST also include the OC-OLR AVP with an
    appropriate content in it (such as a rate based abatement algorithm
    would include the desired rate information AVPs inside the OC-OLR AVP).
   </t>
   <t>Once the endpoint that initiated the request message receives an answer message
    from the remote endpoint, it can detect from the received answer message 
	whether the remote endpoint supports the overload control solution and
	in a case it does, what features are supported. The support for the overload
	control solution is based on the presence of the OC-Feature-Vector and/or
	OC-OLR AVPs for existing application. For the newly defined applications
	the support for the overload control is already part of the application
	specification. Based on capability knowledge the request message initiating
	endpoint can select the preferred common traffic abatement algorithm and act
	accordingly for the subsequent message exchanges.
   </t>
  </section>
  <section title="Answer Message Initiating Endpoint Considerations">
   <t>When a remote endpoint receives a request message in can detect whether
    the request message initiating endpoint has support for the overload
	control solution based on the presence of the OC-Feature-Vector AVP and
	possibly the OC-OLR AVP. For the newly defined applications the overload
	control solution support can be part of the application specification.
	Based on the content of the OC-Feature-Vector AVP and optionally the
	contents of the OC-OLR AVP, the request message receiving endpoint knows
	what overload control functionality the other endpoint supports and then
	act accordingly for the subsequent answer messages it initiates. It is
	RECOMMENDED that the answer message initiating endpoint selects one common
	traffic abatement algorithm even if it would support multiple. The answer
	message initiating endpoint MUST NOT include any overload control solution
	defined AVPs into its answer messages if the request message initiating
	endpoint has not indicated support at the beginning of the the created
	session (or transaction in a case of non-session state maintaining applications).
   </t>
  </section>
 </section>

 <section title="Protocol Extensibility" anchor="ext">
  <t>The overload control solution can be extended, e.g. with new traffic
   abatement algorithms or new functionality. The key aspect to remember
   is to register the new features and algorithms in the IANA and use
   the OC-Feature-Vector for announcing the support for the new
   features (ee <xref target="iana"/> for the required procedures).
  </t>
  <t>It should be noted that <xref target="RFC6733"/> defined
   Grouped AVP extension mechanisms also apply. This allows, for example,
   defining a new feature that is mandatory to understand even when
   piggybacked on an existing applications. More specifically, the sub-AVPs
   inside the OC-OLR AVP MAY have the M-bit set. However, when overload control
   AVPs are piggybacked on top of an existing applications, setting M-bit in
   sub-AVPs is NOT RECOMMENDED.
  </t>
 </section>

 <section title="Overload Report Processing">
  <section title="Sender Endpoint Considerations">
  </section>

  <section title="Receiver Endpoint Considerations">
   <t>
    [Editor's note: did we now agree that e.g. a server can refrain sending
	 OLR in answers based on some magical algorithm?]
   </t>
  </section>
 </section>
</section>

<section title="Transport Considerations" anchor="transport">
 <t>In order to reduce overload control introduced additional AVP
  and message processing it might be desirable/beneficial to signal
  whether the Diameter command carries overload control information
  that should be of interest of an overload aware Diameter node.
 </t>
 <t>Should such indication be include is not part of this
  specification. It has not either been concluded at what layer
  such possible indication should be. Obvious candidates 
  include transport layer protocols (e.g., SCTP PPID or
  TCP flags) or Diameter command header flags.
 </t>
</section>


<section title="IANA Considerations" anchor="iana">
 <section title="AVP codes">
  <t>New AVPs defined by this specification are listed in <xref target="avps"/>.
   All AVP codes allocated from the  'Authentication,  Authorization, and
   Accounting (AAA) Parameters' AVP Codes registry.
  </t>
 </section>
 <section title="Result-Code values">
  <t>This specification adds...:
  </t>
  <figure><artwork><![CDATA[
AVP Values | Attribute Name                | Reference
-----------+-------------------------------+----------
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
 5xxx      | DIAMETER_xx                   | RFCxxxx
]]></artwork></figure>
 </section>
 <section title="New registries">
 <t>Three new registries are needed under the 'Authentication,  Authorization, 
  and Accounting (AAA) Parameters' registry.
 </t>
 <t><xref target="fvec"/> defines a new
  "Overload Control Feature Vector" registry including the initial assignments.
  New values can be added into the registry using the Specification Required
  policy <xref target="RFC5226"/>.
 </t>
 <t><xref target="rtype"/> defines a new "Overload Report Type" registry with
  its initial assignments. New types can be added using the Specification
  Required policy <xref target="RFC5226"/>.
 </t>
 <t><xref target="alg-id"/> defines a new "Overload Control Algorithm" registry
  with its initial assignments. New types can be added using the Specification
  Required policy <xref target="RFC5226"/>.
 </t>
 </section>
</section>

<section title="Security Considerations">
 <t>This mechanism gives Diameter nodes the ability to request that downstream nodes send fewer Diameter requests. Nodes do this by exchanging overload reports that directly affect this reduction. This exchange is potentially subject to multiple methods of attack, and has the potential to be used as a Denial-of-Service (DoS) attack vector.
 </t>
<t>Overload reports may contain information about the topology and current status of a Diameter network. This information is potentially sensitive. Network operators may wish to control disclosure  of overload reports to unauthorized parties to avoid its use for competitive intelligence or to target attacks.
 </t>
<t>Diameter does not include features to provide end-to-end authentication, integrity protection, or confidentiality. This may cause complications when sending overload reports between non-adjacent nodes.</t>
<section title="Denial of Service Attacks">
	<t>Diameter overload reports can cause a node to cease sending some or all Diameter requests for an extended period. This makes them a tempting vector for DoS tacks. Furthermore, since Diameter is almost always used in support of other protocols, a DoS attack on Diameter is likely to impact those protocols as well. </t>
	<t> This is somewhat mitigated by the fact that an overload report only applies to requests related to the Diameter Application of the enclosing Diameter message. Even so, a DoS attack on a single application can be extremely damaging. Therefore, Diameter nodes MUST NOT honor or forward overload reports from unauthorized or otherwise untrusted sources.</t>
</section>
<section title="End-to End-Security Issues">
	<t>Diameter requires nodes to authenticate peers, and to only route messages to and accept messages from peers that are authorized for their particular roles. The required use of TLS, DTLS, or IPSec facilitates peer authentication, and can provide confidentiality and integrity protection of Diameter messages, including overload reports imbedded in messages.</t>
	<t>The lack of end-to-end security features makes it far more difficult to establish trust in overload reports that originate from non-adjacent nodes. Any agents in the message path insert or modify overload reports.  Nodes must trust that their adjacent peers perform proper checks on overload reports from their peers, and so on, creating a transitive-trust requirement extending for potentially long chains of nodes. Network operators must determine if this transitive trust requirement is acceptable for their deployments. Nodes supporting Diameter overload control MUST give operators the ability to select which peers are trusted to deliver overload reports, and whether they are trusted to forward overload reports from non-adjacent nodes.</t>
	<t><list><t>The transitive trust issue is worse if the adjacent peer does not support the overload control mechanism in the first place. An agent that does not support overload control is likely to pass overload reports through without inspecting them or applying any sort of authorization policy. </t></list></t>
	<t>[Open issue: This requires that a responding node be able to tell a peer-generated OLR from one generated by a non-adjacent node. One way of doing this would be to include the identity of the node that generated the report as part of the OLR]</t>
	<t>[Open Issue: Do we need further language about what rules an agent should apply before forwarding an OLR?]</t>
	<t>The lack of end-to-end confidentiality protection means that any Diameter agent in the path of an overload report can view the contents of that report. In addition to the requirement to select which peers are trusted to send overload reports, operators MUST be able to select which peers are authorized to receive reports. A node MUST not send an overload report to a peer not authorized to receive it. Furthermore, an agent MUST remove any overload reports that might have been inserted by other nodes before forwarding a Diameter message to a peer that is not authorized to receive overload reports.</t>
	<t><list><t>At the time of this writing, the DIME working group is studying <xref target="I-D.ietf-dime-e2e-sec-req"> requirements for adding end-to-end security </xref> features to Diameter. These features, when they become available, might make it easier to establish trust in non-adjacent nodes for overload control purposes. Readers should be reminded, however, that the overload control mechanism encourages Diameter agents to modify AVPs in, or insert additional AVPs into, existing messages that are originated by other nodes. If end-to-end security is enabled, there is a risk that such modification could violate integrity protection. The details of using any future Diameter end-to-end security mechanism with overload control will require careful consideration, and are beyond the scope of this document. </t></list></t>	
</section>
<section title="Non-Compliant Nodes">
	<t>When a Diameter node sends an overload report, it cannot assume that all nodes will comply. A non-compliant node might continue to send requests with no reduction in load. <xref target="I-D.ietf-dime-overload-reqs"> Requirement 28 </xref> indicates that the overload control solution cannot assume that all Diameter nodes in a network are necessarily trusted, and that malicious nodes not be allowed to take advantage of the overload control mechanism to get more than their fair share of service.</t>
	<t>In the absence of an overload control mechanism, Diameter nodes need to implement strategies to protect themselves from floods of requests, and to make sure that a disproportionate load from one source does not prevent other sources from receiving service. For example, a Diameter server might reject a certain percentage of requests from sources that exceed certain limits. Overload control can be thought of as an optimization for such strategies, where downstream nodes never send the excess requests in the first place. However, the presence of an overload control mechanism does not remove the need for these other protection strategies.</t>
</section>

</section>

<section title="Design Team Members">
 <t>This document is a product of the following Diameter Overload Control Design Team
  members:
 </t>
 <t><list style="symbols">
  <t>Ben Campbell</t>
  <t>Eric McMurry</t>
  <t>Hannes Tschofenig</t>
  <t>Jean-Jacques Trottin</t>
  <t>Jouni Korhonen</t>
  <t>Lionel Morand</t>
  <t>Maria Cruz Bartolome</t>
  <t>Martin Dolly</t>
  <t>Nirav Salot</t>
  <t>Steve Donovan</t>
  <t>Susan Shishufeng</t>
 </list>
 </t>
</section>


<section title="Acknowledgements">
 <t>...
 </t>
</section>


</middle>

    <!-- ====================================================================== -->

<back>
 <references title="Normative References">
  &RFC2119;
  &RFC6733;
  &RFC5226;
 </references>

 <references title="Informative References">
  &I-D.ietf-dime-overload-reqs;
  &RFC4006;
  &I-D.ietf-dime-e2e-sec-req;
 </references>

    <!-- ====================================================================== -->
 <section title="Issues left for future specifications" anchor="ffs">
  <t>The base solution for the overload control does not cover all
   possible use cases. A number of solution aspects were intentionally
   left for future specification and protocol work.
  </t>
  
  <section title="Additional traffic abatement algorithms">
   <t>This specification describes only means for a simple
    loss based algorithm. Future algorithms can be added using the
	designed solution extension mechanism. The new algorithms
	need to be registered with IANA. See Sections <xref target="fvec"
	format="counter"/>, <xref target="alg-id" format="counter"/> and
	<xref target="iana" format="counter"/> for the required IANA steps. 
   </t>
  </section>
 
  <section title="Agent Overload">
   <t>This specification focuses on Diameter end-point (server or client) overload.
    A separate extension will be required to outline the handling the case of
    agent overload.
   </t>
  </section>
 </section>


<section title="Examples">
  <section title="3GPP S6a interface overload indication">
   <t>Would cover S6a MME-HSS communication with several topology
    choices (such as with or without DRA, and with "generic" agents).
   </t>
  </section>

  <section title="3GPP PCC interfaces overload indication">
   <t>Would cover Gx/Rx and maybe S9.. 
   </t>
  </section>
 </section>



</back>
</rfc>
